/**
 *
 * CA448 Compiler Construction
 * Assignment 2: A Lexical Analyser for the simpL Language
 *
 * This project is my own work. I have not recieved assistance beyond what is
 * normal, and we have cited any sources from which I have borrowed. I have
 * not given a copy of our work, or a part of our work, to anyone. I are aware
 * that copying or giving a copy may have serious consequences.
 *
 *  Reference: https://javacc.java.net/doc/JavaCC.html
 *
 *  @author Ian Duffy, 11356066
 *
 */

options
{
   IGNORE_CASE = false;
   MULTI=true;
   VISITOR=true;
   NODE_DEFAULT_VOID=true;
}


PARSER_BEGIN(SimpL)

import java.io.*;
import java.util.*;

class SimpL {

    public static String scope = "global";
    public static int scopeCounter = 0;
    public static LinkedList<Token> stack = new LinkedList<Token>();
    public static HashMap<String, HashMap<String, STC>> symbolTable = new HashMap<String, HashMap<String, STC>>();

    public static List<Token> popUntil(String until) {
      LinkedList<Token> value = new LinkedList<Token>();
      for (Token token = stack.pop();token!=null;token=stack.pop()) {
        if(token.image.equals(until)) {
            break;
        }
        value.addFirst(token);
      }
      return value;
    }

    public static void main(String[] args) throws ParseException {

      symbolTable.put(scope, new HashMap<String, STC>());

      SimpL parser = new SimpL(System.in);
      ASTProgram program = parser.program();

      System.out.println("Abstract Syntax Tree:");

      program.dump("    ");

	  System.out.println();
	  System.out.println("Semantic Checker:");
	  SemanticCheckVisitor semanticCheckVisitor = new SemanticCheckVisitor();
	  program.jjtAccept(semanticCheckVisitor, symbolTable);

    }
}
PARSER_END(SimpL)

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

// Skip whitespace.
SKIP :
{
    " "
    | "\n"
    | "\t"
    | "\b"
    | "\r"
    | "\f"
}

// Skip comments.
SKIP :
{
    < "--" (~["\r", "\n"]) *>
    | <"/*"> {commentNesting++; } : MULTILINE_COMMENT_STATE
}

// Handle multiline comments.
<MULTILINE_COMMENT_STATE> SKIP :
{
    <"/*"> {
        commentNesting++;
    }
    | "*/" {
        commentNesting--;
        if(commentNesting == 0) SwitchTo(DEFAULT);
      }
    | <~[] >
}


TOKEN :
{
    <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <COMMA: ",">
    | <SEMICOLON: ";">
    | <COLON: ":">
    | <DOT: ".">
    | <ASSIGN: ":=">
    | <QUESTION: "?">
    | <EXCLAMATION: "!">
}

TOKEN :
{
    <ADD: "+">
    | <SUB: "-">
    | <MULT: "*">
    | <DIV: "/">
    | <MOD: "%">
    | <EQ: "=">
    | <NOTEQ: "!=">
    | <LT: "<">
    | <GT: ">">
    | <LE: "<=">
    | <GE: ">=">
}

TOKEN :
{
    < AND : "and" >
    | < BOOL : "boolean" >
    | < CONST : "const" >
    | < DO : "do" >
    | < ELSE : "else" >
    | < FALSE : "false" >
    | < IF : "if" >
    | < INT : "int" >
    | < MAIN : "main" >
    | < NOT : "not" >
    | < OR : "or" >
    | < REAL : "real" >
    | < RETURN : "return" >
    | < STRING : "string" >
    | < THEN : "then" >
    | < TRUE : "true" >
    | < VAR : "var" >
    | < VOID : "void" >
    | < WHILE : "while" >
}

TOKEN :
{
    < NUMBER : <DIGITS> | <DIGITS> "." <DIGITS>>
    | < IDENTIFIER : (<LETTER>)(<DIGIT> | <LETTER> | <UNDERSCORE>)*>
    | <STRINGS: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

TOKEN :
{
    < #DIGIT : (["0" - "9"]) >
    | < #DIGITS : (<DIGIT>)+ >
    | < #LETTER : (["a" - "z", "A" - "Z"]) >
    | < #LETTERS : (<LETTER>)+ >
    | < #UNDERSCORE : ("_") >
}

TOKEN :
{
    <OTHER : ~[]>
}


ASTProgram program() #Program:
{}
{
    (
        (decl())*
        (function())*
        (main_prog())
    ) <EOF>
    {
      return jjtThis;
    }
}

void decl() :
{}
{
    (
        var_decl()
        | const_decl()
    )
}

void var_decl() #VarDecl :
{List<Token> identList;}
{
    <VAR> identList = ident_list() <COLON> type() (<COMMA> identList = ident_list() <COLON> type()
    {
      Token type = stack.pop();
      for(Token identifier : identList) {
        symbolTable.get(scope).put(identifier.image, new STC(identifier, type, scope));
      }
      jjtThis.value = Arrays.asList(type, identList);
    }
    )* <SEMICOLON>
    {
      Token type = stack.pop();
      for(Token identifier : identList) {
        symbolTable.get(scope).put(identifier.image, new STC(identifier, type, scope));
      }
      jjtThis.value = Arrays.asList(type, identList);
    }
}

void const_decl() #const_decl :
{}
{
    <CONST> identifier() <COLON> type() <EQ> expression() (<COMMA> identifier() <COLON> type() <EQ> expression()
    {
      // stack.push(type);
      // stack.push(identifier);
    }
    )* <SEMICOLON>
    {
      // stack.push(type);
      // stack.push(identifier);
    }
}

void function() #Function :
{List<Token> paramList;}
{
    type() identifier() <LPAREN> paramList = param_list() <RPAREN>
    {
      Token identifier = stack.pop();
      Token type = stack.pop();

      HashMap<String, STC> scopedSymbolTable = symbolTable.get(scope);
      STC stc = new STC(identifier, type, scope);
      stc.addData("paramList", paramList);
      scopedSymbolTable.put(identifier.image, stc);
      symbolTable.put(scope, scopedSymbolTable);

      scope = "function-" + ++scopeCounter;
      symbolTable.put(scope, new HashMap<String, STC>());

      jjtThis.value = Arrays.asList(type, identifier, paramList);
    }
    <LBRACE>
    (decl())*
    (statement() <SEMICOLON> )*
    {stack.push(new Token(999, "RETURNVALUE"));} <RETURN> expression() | {} <SEMICOLON>
    <RBRACE>
    {
      List<Token> returnValue = popUntil("RETURNVALUE");
    }
}

List<Token> param_list() #ParamList : {}
{
    {stack.push(new Token(JJTPARAMLIST, jjtNodeName[JJTPARAMLIST]));}
    (identifier() <COLON> type() ( <COMMA> identifier() <COLON> type())* | {})
    {
      List<Token> list = popUntil(jjtNodeName[JJTPARAMLIST]);
      System.out.println(list);
      jjtThis.value = list;
      return list;
    }
}

void type() :
{}
{
    <INT>
    {
      stack.push(token);
    }

    | <BOOL>
    {
      stack.push(token);
    }

    | <REAL>
    {
      stack.push(token);
    }

    | <STRING>
    {
      stack.push(token);
    }


    | <VOID>
    {
      stack.push(token);
    }
}

void main_prog() #Main :
{}
{
    {
      scope = "main";
      symbolTable.put(scope, new HashMap<String, STC>());
    }
    <MAIN><LBRACE>(decl())*(statement()<SEMICOLON>)*<RBRACE>
}

void statement() :
{Token identifier; List<Token> argList;}
{
    identifier = identifier()
    (
      {stack.push(new Token(JJTASSIGNMENT, jjtNodeName[JJTASSIGNMENT]));}
      <ASSIGN> ( expression() | <STRINGS> )
      {
        List<Token> assignment = popUntil(jjtNodeName[JJTASSIGNMENT]);
        stack.pop();
        System.out.println("ASSIGNMENT: " + identifier + " = " + assignment);
        STC symbolTableChild = symbolTable.get(scope).get(identifier.image);

        if(symbolTableChild == null) {
          symbolTableChild = new STC(identifier, scope);
          symbolTableChild.addData("initialized", false);
        }

        if(symbolTableChild.getData("values") == null) {
          symbolTableChild.addData("values", new ArrayList<List<Token>>());
        }

        List<List<Token>> values = (List) symbolTableChild.getData("values");
        values.add(assignment);

        jjtThis.value = Arrays.asList(identifier, assignment);
      } #Assignment
      | <LPAREN> argList=arg_list() <RPAREN>
      {
      	jjtThis.value = Arrays.asList(identifier, argList);
      } #FunctionCall
    )

    | ({stack.push(new Token(JJTEVALUATION, jjtNodeName[JJTEVALUATION]));}
      <EXCLAMATION> expression())
      {
        List<Token> evaluationExp = popUntil(jjtNodeName[JJTEVALUATION]);
      } #Evaluation

    | <QUESTION> identifier()
    {
    	stack.pop();
    }

    | <LBRACE>(statement() <SEMICOLON> )*<RBRACE>
    | <IF> condition() <THEN> statement() <ELSE> statement()
    | <WHILE> condition() <DO> statement()
    | {}
}

void expression() :
{Token identifier; List<Token> argList;}
{
    LOOKAHEAD(2)
    identifier = identifier() <LPAREN> argList = arg_list() {for(Token arg : argList) stack.push(arg); } <RPAREN>
    {
    	jjtThis.value = Arrays.asList(identifier, argList);
    } #FunctionCall
    | term() addSubExpression()
}

void addSubExpression() :
{}
{
    {stack.push(new Token(ADD, tokenImage[ADD]));} <ADD> expression() addSubExpression() #AddExpr(2)
    | {stack.push(new Token(SUB, tokenImage[SUB]));} <SUB> expression() addSubExpression() #SubExpr(2)
    | {}
}

void term() :
{}
{
  fragment() multDivExpression()
}

void multDivExpression() :
{}
{
  {stack.push(new Token(MULT, tokenImage[MULT]));} <MULT> term() multDivExpression() #MultExpr(2)
  | {stack.push(new Token(DIV, tokenImage[DIV]));} <DIV> term() multDivExpression() #DivExpr(2)
  | {}
}

void fragment() :
{}
{
  identifier()
  | number()
  | {stack.push(new Token(ADD, tokenImage[ADD]));} <ADD> fragment()
  | {stack.push(new Token(SUB, tokenImage[SUB]));} <SUB> fragment()
  | <LPAREN> expression() <RPAREN>
}

List<Token> condition() #Condition :
{}
{
    {stack.push(new Token(JJTCONDITION, jjtNodeName[JJTCONDITION]));}
    (<NOT>expression()
    | expression() (<EQ>|<NOTEQ>|<LT>|<GT>|<GE>|<LE>|<AND>|<OR>) expression()
    )
    {
      List<Token> list = popUntil(jjtNodeName[JJTCONDITION]);
      jjtThis.value = list;
      return list;
    }
}

List<Token> ident_list() #IdentList:
{}
{
  {stack.push(new Token(JJTIDENTLIST, jjtNodeName[JJTIDENTLIST]));}
  identifier() list_()
  {
    List<Token> list = popUntil(jjtNodeName[JJTIDENTLIST]);
    jjtThis.value = list;
    return list;
  }
}

List<Token> arg_list() #ArgList:
{}
{
  {stack.push(new Token(JJTARGLIST, jjtNodeName[JJTARGLIST]));}
  identifier() list_()
  {
    List<Token> list = popUntil(jjtNodeName[JJTARGLIST]);
    jjtThis.value = list;
    return list;
  }
}

void list_() :
{}
{
    <COMMA> identifier() list_() | {}
}

void number() #Number:
{}
{
  <NUMBER>
  {
    stack.push(token);
    jjtThis.value = token;
  }
}

Token identifier() #Identifier : {}
{
  <IDENTIFIER>
  {
    stack.push(token);
    jjtThis.value = token;
    return token;
  }
}
