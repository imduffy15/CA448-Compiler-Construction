/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SimpL.jj */
/*@egen*//**
 *
 * CA448 Compiler Construction
 * Assignment 2: A Lexical Analyser for the simpL Language
 *
 * This project is my own work. I have not recieved assistance beyond what is
 * normal, and we have cited any sources from which I have borrowed. I have
 * not given a copy of our work, or a part of our work, to anyone. I are aware
 * that copying or giving a copy may have serious consequences.
 *
 *  Reference: https://javacc.java.net/doc/JavaCC.html
 *
 *  @author Ian Duffy, 11356066
 *
 */

options
{
  IGNORE_CASE = false;
               
                 
}


PARSER_BEGIN(SimpL)

import java.io.*;
import java.util.*;

class SimpL/*@bgen(jjtree)*/implements SimpLTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTSimpLState jjtree = new JJTSimpLState();

/*@egen*/

    public static Hashtable<String, STC> ST = new Hashtable<String, STC>();

    public static void main(String[] args) throws ParseException {
      SimpL parser = new SimpL(System.in);
      SimpleNode root = parser.program();

      System.out.println("Abstract Syntax Tree:");

      root.dump(" ");

      System.out.println();
      System.out.println("Symbol Table:");

      for(String key : ST.keySet()) {
        STC temp2 = ST.get(key);
        System.out.println(temp2);
        if(temp2.type != null) {
            System.out.println(" type = " + temp2.type);
        }
        if(temp2.value != null) {
            System.out.println(" value = " + temp2.value);
        }
      }

      // System.out.println();
      // System.out.println("Program:");
      // PrintVisitor pv = new PrintVisitor();
      // root.jjtAccept(pv, null);

      System.out.println();
      System.out.println("Type Checking:");
      TypeCheckingVisitor tc = new TypeCheckingVisitor();
      root.jjtAccept(tc, ST);
    }
}
PARSER_END(SimpL)

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

// Skip whitespace.
SKIP :
{
    " "
    | "\n"
    | "\t"
    | "\b"
    | "\r"
    | "\f"
}

// Skip comments.
SKIP :
{
    < "--" (~["\r", "\n"]) *>
    | <"/*"> {commentNesting++; } : MULTILINE_COMMENT_STATE
}

// Handle multiline comments.
<MULTILINE_COMMENT_STATE> SKIP :
{
    <"/*"> {
        commentNesting++;
    }
    | "*/" {
        commentNesting--;
        if(commentNesting == 0) SwitchTo(DEFAULT);
      }
    | <~[] >
}


TOKEN :
{
    <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <COMMA: ",">
    | <SEMICOLON: ";">
    | <COLON: ":">
    | <DOT: ".">
    | <ASSIGN: ":=">
    | <QUESTION: "?">
    | <EXCLAMATION: "!">
}

TOKEN :
{
    <ADD: "+">
    | <SUB: "-">
    | <MULT: "*">
    | <DIV: "/">
    | <MOD: "%">
    | <EQ: "=">
    | <NOTEQ: "!=">
    | <LT: "<">
    | <GT: ">">
    | <LE: "<=">
    | <GE: ">=">
}

TOKEN :
{
    < AND : "and" >
    | < BOOL : "boolean" >
    | < CONST : "const" >
    | < DO : "do" >
    | < ELSE : "else" >
    | < FALSE : "false" >
    | < IF : "if" >
    | < INT : "int" >
    | < MAIN : "main" >
    | < NOT : "not" >
    | < OR : "or" >
    | < REAL : "real" >
    | < RETURN : "return" >
    | < STRING : "string" >
    | < THEN : "then" >
    | < TRUE : "true" >
    | < VAR : "var" >
    | < VOID : "void" >
    | < WHILE : "while" >
}

TOKEN :
{
    < NUMBER : <DIGITS> | <DIGITS> "." <DIGITS>>
    | < IDENTIFIER : (<LETTER>)(<DIGIT> | <LETTER> | <UNDERSCORE>)*>
    | <STRINGS: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?
                                                                            | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

TOKEN :
{
    < #DIGIT : (["0" - "9"]) >
    | < #DIGITS : (<DIGIT>)+ >
    | < #LETTER : (["a" - "z", "A" - "Z"]) >
    | < #LETTERS : (<LETTER>)+ >
    | < #UNDERSCORE : ("_") >
}

TOKEN :
{
    <OTHER : ~[]>
}


SimpleNode program() : {/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) program */
    try {
/*@egen*/
    (
        (decl())*
        (function())*
        (main_prog())
    ) <EOF>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void decl()       : {}
{
    (
        var_decl() | const_decl()
    )
}

void var_decl() : {/*@bgen(jjtree) var_decl */
  ASTvar_decl jjtn000 = new ASTvar_decl(JJTVAR_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) var_decl */
    try {
/*@egen*/
    <VAR> ident_list() <COLON> type() (<COMMA> ident_list() <COLON> type())* <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void const_decl() : {/*@bgen(jjtree) const_decl */
  ASTconst_decl jjtn000 = new ASTconst_decl(JJTCONST_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) const_decl */
    try {
/*@egen*/
    <CONST> identifier() <COLON> type() <EQ> expression() (<COMMA> identifier() <COLON>
                                                            type() <EQ> expression())*<SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void function()       : {}
{
    type() identifier() <LPAREN>param_list()<RPAREN>
    <LBRACE>
    (decl())*
    (statement() <SEMICOLON> )*
    <RETURN> expression() | {} <SEMICOLON>
    <RBRACE>

}

void param_list() : {/*@bgen(jjtree) param_list */
  ASTparam_list jjtn000 = new ASTparam_list(JJTPARAM_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) param_list */
    try {
/*@egen*/
    (identifier() <COLON> type() ( <COMMA> identifier() <COLON> type() )* |/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/ {})/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void type()       : {}
{
    <INT> | <BOOL> | <REAL> | <STRING> | <VOID>
}

void main_prog()       : {}
{
    <MAIN><LBRACE>(decl())*(statement()<SEMICOLON>)*<RBRACE>
}

void statement()       : {}
{
   identifier()
      (   <ASSIGN> ( expression() | <STRING> )
      |   <LPAREN> arg_list() <RPAREN>
      )
    | <EXCLAMATION> expression()
    | <QUESTION> identifier()
    | <LBRACE>(statement() <SEMICOLON> )*<RBRACE>
    | <IF> condition() <THEN> statement() <ELSE> statement()
    | <WHILE> condition() <DO> statement()
    | {}
}

void expression() : {/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    LOOKAHEAD(2)
    identifier() <LPAREN> arg_list() <RPAREN> | term() expression_()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expression_()       : {}
{
    (<ADD> | <SUB>) expression() expression_() | {}
}

void term()       : {}
{
  fragment() term_()
}

void term_()       : {}
{
  (<MULT> | <DIV>) term() term_() | {}
}

void fragment()       : {}
{
  identifier()
  | number()
  | (<ADD> | <SUB>) fragment()
  | <LPAREN> expression() <RPAREN>
}

void condition()       : {}
{
    <NOT>expression()
    | expression() (<EQ>|<NOTEQ>|<LT>|<GT>|<GE>|<LE>|<AND>|<OR>) expression()
}

void ident_list()       : {}
{
    identifier() list_()
}

void arg_list()       : {}
{
    identifier() list_()
}

void list_()       : {}
{
    <COMMA> identifier() list_() | {}
}

void number() : {/*@bgen(jjtree) number */
                 ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) number */
  try {
/*@egen*/
  t = <NUMBER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String identifier() : {/*@bgen(jjtree) identifier */
                       ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) identifier */
  try {
/*@egen*/
  t = <IDENTIFIER>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}