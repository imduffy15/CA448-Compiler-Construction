/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SimpL.jj */
/*@egen*//**
 *
 * CA448 Compiler Construction
 * Assignment 1: A Lexical Analyser for the simpL Language
 *
 * This project is my own work. I have not recieved assistance beyond what is
 * normal, and we have cited any sources from which I have borrowed. I have
 * not given a copy of our work, or a part of our work, to anyone. I are aware
 * that copying or giving a copy may have serious consequences.
 *
 *  Reference: https://javacc.java.net/doc/JavaCC.html
 *
 *  @author Ian Duffy, 11356066
 *
 */

options {
    DEBUG_PARSER = true;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(SimpL)

import java.util.HashSet;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

class SimpL/*@bgen(jjtree)*/implements SimpLTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTSimpLState jjtree = new JJTSimpLState();

/*@egen*/
    public static void main(String[] args) throws ParseException {

        SimpL parser = new SimpL(System.in);
        SimpleNode root = parser.program();
        root.dump("");
    }
}
PARSER_END(SimpL)

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

// Skip whitespace.
SKIP :
{
    " "
    | "\n"
    | "\t"
    | "\b"
    | "\r"
    | "\f"
}

// Skip comments.
SKIP :
{
    < "--" (~["\r", "\n"]) *>
    | <"/*"> {commentNesting++; } : MULTILINE_COMMENT_STATE
}

// Handle multiline comments.
<MULTILINE_COMMENT_STATE> SKIP :
{
    <"/*"> {
        commentNesting++;
    }
    | "*/" {
        commentNesting--;
        if(commentNesting == 0) SwitchTo(DEFAULT);
      }
    | <~[] >
}


TOKEN :
{
    <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <COMMA: ",">
    | <SEMICOLON: ";">
    | <COLON: ":">
    | <DOT: ".">
    | <ASSIGN: ":=">
    | <QUESTION: "?">
    | <EXCLAMATION: "!">
}

TOKEN :
{
    <ADD: "+">
    | <SUB: "-">
    | <MULT: "*">
    | <DIV: "/">
    | <MOD: "%">
    | <EQ: "=">
    | <NOTEQ: "!=">
    | <LT: "<">
    | <GT: ">">
    | <LE: "<=">
    | <GE: ">=">
}

TOKEN :
{
    < AND : "and" >
    | < BOOL : "boolean" >
    | < CONST : "const" >
    | < DO : "do" >
    | < ELSE : "else" >
    | < FALSE : "false" >
    | < IF : "if" >
    | < INT : "int" >
    | < MAIN : "main" >
    | < NOT : "not" >
    | < OR : "or" >
    | < REAL : "real" >
    | < RETURN : "return" >
    | < STRING : "string" >
    | < THEN : "then" >
    | < TRUE : "true" >
    | < VAR : "var" >
    | < VOID : "void" >
    | < WHILE : "while" >
}

TOKEN :
{
    < NUMBER : <DIGITS> | <DIGITS> "." <DIGITS>>
    | < IDENTIFIER : (<LETTER>)(<DIGIT> | <LETTER> | <UNDERSCORE>)*>
    | <STRINGS: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?
                                                                            | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

TOKEN :
{
    < #DIGIT : (["0" - "9"]) >
    | < #DIGITS : (<DIGIT>)+ >
    | < #LETTER : (["a" - "z", "A" - "Z"]) >
    | < #LETTERS : (<LETTER>)+ >
    | < #UNDERSCORE : ("_") >
}

TOKEN :
{
    <OTHER : ~[]>
}


SimpleNode program() : {/*@bgen(jjtree) program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) program */
    try {
/*@egen*/
    (
        (decl())*
        (function())*
        (main_prog())
    ) <EOF>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void decl() : {/*@bgen(jjtree) decl */
  SimpleNode jjtn000 = new SimpleNode(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) decl */
    try {
/*@egen*/
    (
        var_decl() | const_decl()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void var_decl() : {/*@bgen(jjtree) var_decl */
  SimpleNode jjtn000 = new SimpleNode(JJTVAR_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) var_decl */
    try {
/*@egen*/
    <VAR> ident_list() <COLON> type() (<COMMA> ident_list() <COLON> type())* <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void const_decl() : {/*@bgen(jjtree) const_decl */
  SimpleNode jjtn000 = new SimpleNode(JJTCONST_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) const_decl */
    try {
/*@egen*/
    <CONST> <IDENTIFIER> <COLON> type() <EQ> expression() (<COMMA> <IDENTIFIER> <COLON> type() <EQ> expression())*<SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void function() : {/*@bgen(jjtree) function */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) function */
    try {
/*@egen*/
    type() <IDENTIFIER> <LPAREN>param_list()<RPAREN>
    <LBRACE>
    (decl())*
    (statement() <SEMICOLON> )*
    <RETURN> expression() | {} <SEMICOLON>
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

void param_list() : {/*@bgen(jjtree) param_list */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAM_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) param_list */
    try {
/*@egen*/
    (<IDENTIFIER> <COLON> type() ( <COMMA> <IDENTIFIER> <COLON> type() )* |/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/ {})/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void type() : {/*@bgen(jjtree) type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type */
    try {
/*@egen*/
    <INT> | <BOOL> | <REAL> | <STRING> | <VOID>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void main_prog() : {/*@bgen(jjtree) main_prog */
  SimpleNode jjtn000 = new SimpleNode(JJTMAIN_PROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) main_prog */
    try {
/*@egen*/
    <MAIN><LBRACE>(decl())*(statement()<SEMICOLON>)*<RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement() : {/*@bgen(jjtree) statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
   try {
/*@egen*/
   <IDENTIFIER>
      (   <ASSIGN> ( expression() | <STRING> )
      |   <LPAREN> arg_list() <RPAREN>
      )
    | <EXCLAMATION> expression()
    | <QUESTION> <IDENTIFIER>
    | <LBRACE>(statement() <SEMICOLON> )*<RBRACE>
    | <IF> condition() <THEN> statement() <ELSE> statement()
    | <WHILE> condition() <DO> statement()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ {}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void expression() : {/*@bgen(jjtree) expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    LOOKAHEAD(2)
	<IDENTIFIER> <LPAREN> arg_list() <RPAREN> | term() (LOOKAHEAD(2) (<ADD> | <SUB>) expression())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void term() : {/*@bgen(jjtree) term */
  SimpleNode jjtn000 = new SimpleNode(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) term */
        try {
/*@egen*/
	fragment() (LOOKAHEAD(2) (<MULT> | <DIV> ) term())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void fragment() : {/*@bgen(jjtree) fragment */
  SimpleNode jjtn000 = new SimpleNode(JJTFRAGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) fragment */
        try {
/*@egen*/
	<IDENTIFIER>
	| <NUMBER>
	| <LPAREN> expression() <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void condition() : {/*@bgen(jjtree) condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) condition */
    try {
/*@egen*/
    <NOT>expression()
    | expression() (<EQ>|<NOTEQ>|<LT>|<GT>|<GE>|<LE>|<AND>|<OR>) expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ident_list() : {/*@bgen(jjtree) ident_list */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENT_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ident_list */
    try {
/*@egen*/
    <IDENTIFIER> (<COMMA> <IDENTIFIER> )*/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arg_list() : {/*@bgen(jjtree) arg_list */
  SimpleNode jjtn000 = new SimpleNode(JJTARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) arg_list */
    try {
/*@egen*/
    ( <IDENTIFIER> ( <COMMA> <IDENTIFIER>)* |/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ {})/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}